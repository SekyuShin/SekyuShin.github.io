---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



DP 문제 풀이들

# 1. 문제풀이 [1로 만들기] (1463)
Issue : <https://www.acmicpc.net/problem/1463>
## 1) 문제 조건
	- 정수 X에 관한 경우의 수
		- X가 3으로 나누어 떨어지면, 3으로 나눈다.
		- X가 2로 나누어 떨어지면, 2로 나눈다.
		- 1을 뺀다.
	- N은 1보다 크거나 같고, 10^6보다 작거나 같은 정수
## 2) 문제 접근
	1. 우선 10^6은 최대 값이 100만이다.
	2. 그냥 그리드 알고리즘으로 가능할 거 같은데..
		- 안된다. 물론 모든 경우의 수를 계산했을 경우에는 가능하겠지만.
			 ex) 10인 경우, 10->5->4->2->1 로 총 4번 그러나 최소값이기 때문에
				10->9->3->1 로 총 3번의 경우의 수가 나올 수 있다.
	3. 단순히 생각해보자.
		- f(1)은 0
		- f(2)는 1 (2->1)
		- f(3)은 1 (3->1)
		- f(4)는 2 (4->2->1(즉, 4->f(2)) or 4->3->1 (즉, 4->f(3)))
		- f(5)는 3 (5->f(4))
		- f(6)은 2 (6->f(3) or 6->f(2) or 6->f(5)(단, 이 경우는 최소값이 4이다.))


# 2. 코드 (1463)
```c
#include<cstdio>
int main() {
	int n;
	int count = 0;
	int *F = new int[1000001];
	
	scanf("%d", &n);
	F[1] = 0;

	for (int i = 2; i < n+1; i++) {
		count = F[i - 1];
		if (i % 3 == 0 && F[i/3] < count) count = F[i / 3];
		if (i % 2 == 0 && F[i / 2] < count) count = F[i / 2];
		F[i] = count + 1;
	}

	printf("%d\n", F[n]);
	return 0;
}


```

# 3. 리뷰 (1463)

	- DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 사실 적으면서 이게 맞나 싶기도 하니..
	우선 계속 해보자.

	PS. 다른 사람들의 문제를 보니, 재귀함수를 많이 쓴다. 흠.. 재귀함수로는 내일 도전!

# 4. 코드 (1463)
```c
#include<cstdio>
#include<algorithm>
int f(int n) {
	int a,b;
	if(n<2) 
		return 0;
	a=f(n/2)+n%2+1;
	b=f(n/3)+n%3+1;
	return std::min(a,b);
}
main(){
	int n;
	scanf("%d",&n);
	printf("%d",f(n));
}
```

# 4. 리뷰 (1463)
	- 일반적으로 dp문제를 풀 경우, 반복문을 사용하거나 재귀함수를 사용한다고 한다.
	위 풀이는 재귀함수를 사용한 예제다.
	조금 풀이를 해보자면, 나눈셈에 대한 몫만큼만 재귀함수를 사용하며 이후 카운트는 나눗셈에 대한 나머지와 1을 해준다. 뭔가 이해는 가지만 어떻게 이런 풀이가 가능한지 조금 더 생각해봐야겠다.


	
# 1. 문제풀이 [2×n 타일링] (11726)
Issue : <https://www.acmicpc.net/problem/11726>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (3)
		n=4 => 경우의 수 (5)
		n=5 => 경우의 수 (8)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)
		즉, 피보나치 수열이다. (물론 두번째 값부터 조금 다르긴하다.)
	3. 일단 재귀함수로 진행했으나, 시간초과
	4. 다음은 공식을 적용시켜보았으나, 출력값이 너무 커서 오버플로우 발생
		-> 최대 크기의 자료형 또한 오버플로우가 난다.
	5. 그래서 반복문을 통해 이전 기록을 저장한 후에 진행해보니 성공
	
# 2. 코드 (11726)

```cpp
#include<cstdio>
#include<math.h>
const double pi = (1 + sqrt(5)) / 2;
int Fibo(int n) { return round(pow(pi, n) / sqrt(5)); }
//공식 쓰기 => 실패 : 반환값이 너무 커서 오버플로우가 일어난다.


int F(int n) {
	if (n == 1) return 1;
	else if (n == 2) return 2;
	else return F(n - 2) + F(n - 1);
}
//재귀함수 => 실패 : 시간초과

int main() {
	int n;
	int dp[10008];
	dp[1] = 1;
	dp[2] = 2;
	scanf("%d", &n);
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + dp[i-2] )  % 10007; //피보나치 수열 응용?
	}
	printf("%d\n", dp[n]);
	return 0;
}


```

# 3. 리뷰 (11726)

	- dp에 관해 약간의 감을 잡은 것 같긴하다. 재귀함수도 진행해보니 마무리 조건만 잘 적용하면 쉬워 보이긴한다. 그러나 메모리를 보니 생각보다 많다.
	%10007을 준 이유가 나누기를 그리해서 그런건데 생각해보니 n값은 1000이다.
	그리고 사실 이전값 두 개만 필요하니 사실 배열은 세 개만 필요하지 않을까?

		
# 1. 문제풀이 [2×n 타일링2] (11727)
Issue : <https://www.acmicpc.net/problem/11727>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1, 2x2로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (3)
		n=3 => 경우의 수 (5)
		n=4 => 경우의 수 (11)
		n=5 => 경우의 수 (21)

		여기서 규칙을 발견했다. F(n) = F(n-1)+2*F(n-2)
	3. 이전 코드에서 x2를 추가해 주었다.
	
# 2. 코드 (11727)

```cpp
#include<cstdio>

int main() {
	int n;
	int dp[1001];
	dp[1] = 1;
	dp[2] = 3;
	scanf("%d", &n);
	
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + 2*dp[i-2] )  % 10007;
	}
	printf("%d\n", dp[n]);
	return 0;
}

```

# 3. 리뷰 (11727)

	- 음주를 조금 한 상태에서 하느라 시간이 조금 걸렸다. 그러나 이전 코드와 비슷하게 진행되어서 생각보다는 수월하게 한 듯 싶다.



		
# 1. 문제풀이 [1, 2, 3 더하기] (9095)
Issue : <https://www.acmicpc.net/problem/9095>
## 1) 문제 조건
	- 케이스의 개수 T
	- 각각의 정수 n
	- n을 1, 2, 3의 합으로 나타내는 방법
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (4)
		n=4 => 경우의 수 (7)
		n=5 => 경우의 수 (13)
		n=6 => 경우의 수 (24)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)+f(n-3)
	
# 2. 코드 (9095)

```cpp
#include<cstdio>

int main() {
	int n;
	int t;
	int dp[11];
	dp[0] = 0;
	dp[1] = 1;
	dp[2] = 2;
	dp[3] = 4;
	for(int i=4; i<=10; i++) dp[i] = (dp[i-1] + dp[i-2]+dp[i-3]);
	scanf("%d", &t);
	for (int i = 0; i < t; i++) {
		scanf("%d", &n);
		printf("%d\n", dp[n]);
	}
	return 0;
}
```

# 3. 리뷰 (9095)

	- n의 범위가 10이하 였기에 반복문으로 미리 구하고 돌렸다.
	그리고 사실 생각하고 있던건, n이 4일 경우
	[ ]1[ ]1[ ]1[ ]1[ ]
	이런식으로 괄호를 채우는 경우의 수를 구하는 거였는데, 완전탐색으로는 구현할 수 있지 않을가 싶어서 생각해 봤었다.


		
<del>

		
# 1. 문제풀이 [쉬운 계단 수] (10844)
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (9)
		n=2 => 경우의 수 (18 - 1)
		n=3 => 경우의 수 (36 - 4)
		n=4 => 경우의 수 (72 - 10)

		여기서 규칙 - 부분이 수열의 합의 규칙을 갖는다.
		해서 minus dp를 따로 구해주었다.

	
# 2. 코드 (10844)

```cpp
#include<cstdio>
#include<cmath>
int main() {
	int n;
	int dp_tmp=1; //dp[2]일때, -되는 값
	int dp[101];
	int minus_dp[101];
	scanf("%d", &n);
	//int tmp = (9 * pow(2, n - 1) - pow(2, n - 2));
	dp[1] = 9;
	dp[2] = 18;
	minus_dp[1] = 0;
	minus_dp[2] = 1;
	for (int i = 3; i < n+1; i++) {
		dp[i] = dp[i-1]*2 % 1000000000;
		if (dp[i - 1] * 2 > 1000000000) printf("over dp[%d] = %d\n", i, dp[i]);
		minus_dp[i] = (2 * minus_dp[i-1] + 2)%1000000000;
		if ((2 * minus_dp[i-1] + 2) > 1000000000) printf("over minus_dp[%d] = %d\n", i, minus_dp[i]);
	}
	printf("%d\n",  dp[n]- minus_dp[n]);

	return 0;
}


```
</del>

# 3. 리뷰 (10844)
	- 실패
	- 점화식이 잘못되었다. 더욱 큰수들에게서 언제든 뒷자리가 9또는 0이 나올 가능성이 있어서 해당 코드는 맞지않는 코드였다.

# 1. 문제풀이 [쉬운 계단 수] (10844) -again
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 1의 자리 숫자의 개수들로 초점을 맞추면
		idx   0 1 2 3 4 5 6 7 8 9
		dp[0] 0 1 1 1 1 1 1 1 1 1
		=> 1,2,3,4,5,6,7,8,9

		idx   0 1 2 3 4 5 6 7 8 9
		dp[1] 1 1 2 2 2 2 2 2 2 1
		=> 10, 21, 12|32, 23|43..... 78|98, 89 

		idx   0 1 2 3 4 5 6 7 8 9
		dp[2] 1 3 3 4 4 4 4 4 3 2
		=> 210, 101|121|321, 212|232|432, 678|878|898, 789|989

		여기서 규칙을 알 수 있다.
		0과 9를 제외한 dp들은 dp[n][j] = dp[n-1][j-1] + dp[n-1][j+1]를 만족한다. (대각선으로 더하면 된다.)

	
# 2. 코드 (10844)

```cpp
#include<cstdio>

int main() {
	int n;
	int result=0; 
	int dp[2][10] = { 0,  };
	scanf("%d", &n);

	for (int i = 1; i < 10; i++) dp[1][i] = 1;

	for (int i = 2; i < n+1; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 0) dp[i % 2][j] = dp[(i - 1) % 2][j + 1] % 1000000000;
			else if (j == 9) dp[i % 2][j] = dp[(i - 1) % 2][j - 1] % 1000000000;
			else dp[i % 2][j] = (dp[(i - 1) % 2][j - 1] + dp[(i - 1) % 2][j + 1]) % 1000000000;
		}
	}

	for (int i = 0; i < 10; i++) result = (result + dp[n % 2][i]) % 1000000000;
	printf("%d\n", result);

	return 0;
}
```

# 3. 리뷰 (10844)

>	 이런식으로 생각할 생각을 아예 못했다. 매우 신박하다.
	이래서 1시간동안 고민하고 못 풀면 해답을 보란말이 매우 와 닿는다.
	
>	추가로 상기 코드는 2개의 배열만을 가지고 윗배열 아랫배열의 값을 참조하는
	 식의 형태인 `슬라이딩 윈도 기법`이라고 한다.

		

# 1. 문제풀이 [오르막 수] (11057)
Issue : <https://www.acmicpc.net/problem/11057>
## 1) 문제 조건
	- N (1 ≤ N ≤ 1,000)
	- 0으로 시작가능
	- 오르막 개수 (ex. 11, 12, 19 etc..)
	- 출력 : 10,007로 나눈 나머지
## 2) 문제 접근(1) - 실패
	1. 완전탐색? - 실패 (1000까지 숫자인줄 알고 완전탐색으로 진행했다가 생각해보니 1000자리수..)
## 3) 문제 접근(2)
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 1의 자리 숫자의 개수들로 초점을 맞추면
		idx   0 1 2 3 4 5 6 7 8 9
		dp[0] 1 1 1 1 1 1 1 1 1 1
		=> 0,1,2,3,4,5,6,7,8,9

		idx   0 1 2 3 4 5 6 7 8 9
		dp[1] 1 2 3 4 5 6 7 8 9 10
		=> 00 
		=> 01 11
		=> 02 12 22
		=> 03 13 23 33
		...
		=> 09 19 29 39 49 59 69 79 89 99

		idx   0 1 2  3  4  5  6  7  8  9
		dp[2] 1 3 6 10 15 21 28 36 45 55
		=> 000
		=> 001 011 111
		=> 002 012 112 022 122 222
		...
		=> 009 019 119 029 129 229 039... 099 199 299.. 899 999 (55)

	3. 규칙을 찾아보면, idx를 보면 자기자신을 포함한 작은 수의 idx들을 전부 더한값이 현재 idx의 값이란 것을 알 수 있다.
		ex)	dp[2][3] = dp[1][0]+dp[1][1]+dp[1][2]+dp[1][3] = 1+2+3+4 = 10

# 2. 코드 (11057) 

## 1. 실패 코드 (완전탐색)
```cpp
#include<cstdio>
#include<cmath>
int main() {
	int n;
	int count = 0;
	scanf("%d", &n);
	n = pow(10, n) - 1;
	for (int i = 1; i <= n; i++) {
		
		int tmp = i;
		int j_count = 0;
		bool checkUp = true;
		do {
			tmp /= 10;
			j_count++;
		} while (tmp > 0);
		//printf("%d : ", i);
		tmp = i;
		if (i > 10) {
			for (int j = j_count; j > 1; j--) {
				int tmp2 = tmp / pow(10, j-1);
				tmp =tmp % (int)pow(10, j-1);
				if (tmp2 > tmp / pow(10, j - 2)) {
					checkUp = false;
					break;
				}
				//printf("%d, %d\n", tmp2, tmp);
			}
			if (checkUp) count++;
		}
		else count++;

	}
	printf("%d\n", count);
	return 0;
}


```

## 2. 성공 코드 (DP)

```cpp
#include<cstdio>
int main() {
	int n;
	int dp[2][10] = { 0, };
	int ret = 0;
	scanf("%d", &n);

	for (int i = 0; i < 10; i++) {
		dp[1][i] = 1;
	}
	for (int i = 2; i < n + 1; i++) {
		for (int j = 0; j < 10; j++) {
			dp[i % 2][j] = 0;
			for (int z = 0; z < j + 1; z++) {
				dp[i % 2][j] += (dp[(i - 1) % 2][z] % 10007);
			}
		}
	}
	for (int i = 0; i < 10; i++) {
		ret += dp[n % 2][i]%10007;
	}
	printf("%d\n", ret % 10007);
	return 0;
}

```

# 3. 리뷰 (11057)

>	 위에서 풀었던 10844번 문제와 유사해서 금방 해결했던것 같다. 사실 DP문제기에 바로 배열을 두고 10844번 문제와 같이 풀 생각을 우선 하였지만, 1000이란 숫자에 완전탐색도 가능하지 않을까 시작했었다. (문제 지문 잘못 이해)

> 코드를 리뷰해 보자면, dp 배열을 두개로 둔  `슬라이딩 윈도 기법`을 사용했다. 다만 지금 보니 배열 한 개로 충분히 해결할 수 있어 보인다.

```cpp
	int dp[10] ={1,};
	for(int i=0;i<n;i++) {
		for(int j=1;j<10;j++) {
			dp[j] +=dp[j-1];
		}
	}
```
> <del>이런식으로 가능할 것 같다.</del> 임시 테스트를 잠시 진행해보니 가능하다. 메모리 낭비 및 시간 복잡도상 시간 낭비..

			

# 1. 문제풀이 [이친수] (2193)
Issue : <https://www.acmicpc.net/problem/2193>
## 1) 문제 조건
	- 0으로 시작하지 않는다.
	- 1이 두 번 연속으로 나타나지 않는다.
	- N(1 ≤ N ≤ 90)
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 우선 풀어서 찾아보자면
		dp[1] = 1 => 1
		dp[2] = 1 => 10
		dp[3] = 2 => 101, 100
		dp[4] = 3 => 1010, 1001, 1000
		dp[5] = 5 => 10100, 10101, 10010, 10001, 100000

		두 가지를 찾을 수 있는데, 하나는 맨 뒷자리가 0이면 다음 dp 인자로 1,0이 뒤에 붙어서 나올수 있으며, 맨 뒷자리가 1이면 무조건 1만 나와야한다.
		즉, 인덱스 0, 1을두고 
			idx   0 1
			dp[1] 0 1
			dp[2] 1 0
			dp[3] 1 1
			dp[4] 2 1
			dp[5] 3 2

		이런 식으로 dp[n][0] = dp[n-1][0] + dp[n-1][1]
				   dp[n][1] = dp[n-1][0]
		로 표현 가능해 진다.

		또는
		1, 1, 2, 3, 5의 규칙성을 보았을 때,
		dp[n] = dp[n-1] + dp[n-2]로 표현되기도 한다.

		n의 크기가 작기에 두 번째 방법으로 도출되어질 것 같아 두 번째 방법을 사용했다.
		
# 2. 코드 (2193) 

```cpp
#include<cstdio>
#include<iostream>

using namespace std;
int main() {
	unsigned long long  dp[91] = { 1,1, 1 };
	int n = 0;
	
	scanf("%d", &n);

	for (int i = 3; i <= n; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}

	cout << dp[n] << endl;
	
	return 0;
}



```

# 3. 리뷰 (2193)

>	 n의 크기가 90 이하지만 수 는 상당히 커진다. 그래서 처음 오버플로우가 발생했으나,
	 확인한 결과 8byte로 표현 가능한 수여서 그대로 진행하였다.

> 추가로 cout으로 표현해 주었는데, `printf`로 표현하기 위해서 출력형식을 `%lld`로 해주면 출력 가능해진다.
