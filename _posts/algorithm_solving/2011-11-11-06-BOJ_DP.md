---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



DP 문제 풀이들

# 1. 문제풀이 [1로 만들기] (1463)
Issue : <https://www.acmicpc.net/problem/1463>
## 1) 문제 조건
	- 정수 X에 관한 경우의 수
		- X가 3으로 나누어 떨어지면, 3으로 나눈다.
		- X가 2로 나누어 떨어지면, 2로 나눈다.
		- 1을 뺀다.
	- N은 1보다 크거나 같고, 10^6보다 작거나 같은 정수
## 2) 문제 접근
	1. 우선 10^6은 최대 값이 100만이다.
	2. 그냥 그리드 알고리즘으로 가능할 거 같은데..
		- 안된다. 물론 모든 경우의 수를 계산했을 경우에는 가능하겠지만.
			 ex) 10인 경우, 10->5->4->2->1 로 총 4번 그러나 최소값이기 때문에
				10->9->3->1 로 총 3번의 경우의 수가 나올 수 있다.
	3. 단순히 생각해보자.
		- f(1)은 0
		- f(2)는 1 (2->1)
		- f(3)은 1 (3->1)
		- f(4)는 2 (4->2->1(즉, 4->f(2)) or 4->3->1 (즉, 4->f(3)))
		- f(5)는 3 (5->f(4))
		- f(6)은 2 (6->f(3) or 6->f(2) or 6->f(5)(단, 이 경우는 최소값이 4이다.))


# 2. 코드 (1463)
```c
#include<cstdio>
int main() {
	int n;
	int count = 0;
	int *F = new int[1000001];
	
	scanf("%d", &n);
	F[1] = 0;

	for (int i = 2; i < n+1; i++) {
		count = F[i - 1];
		if (i % 3 == 0 && F[i/3] < count) count = F[i / 3];
		if (i % 2 == 0 && F[i / 2] < count) count = F[i / 2];
		F[i] = count + 1;
	}

	printf("%d\n", F[n]);
	return 0;
}


```

# 3. 리뷰 (1463)

	- DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 사실 적으면서 이게 맞나 싶기도 하니..
	우선 계속 해보자.

	PS. 다른 사람들의 문제를 보니, 재귀함수를 많이 쓴다. 흠.. 재귀함수로는 내일 도전!

# 4. 코드 (1463)
```c
#include<cstdio>
#include<algorithm>
int f(int n) {
	int a,b;
	if(n<2) 
		return 0;
	a=f(n/2)+n%2+1;
	b=f(n/3)+n%3+1;
	return std::min(a,b);
}
main(){
	int n;
	scanf("%d",&n);
	printf("%d",f(n));
}
```

# 4. 리뷰 (1463)
	- 일반적으로 dp문제를 풀 경우, 반복문을 사용하거나 재귀함수를 사용한다고 한다.
	위 풀이는 재귀함수를 사용한 예제다.
	조금 풀이를 해보자면, 나눈셈에 대한 몫만큼만 재귀함수를 사용하며 이후 카운트는 나눗셈에 대한 나머지와 1을 해준다. 뭔가 이해는 가지만 어떻게 이런 풀이가 가능한지 조금 더 생각해봐야겠다.


	
# 1. 문제풀이 [2×n 타일링] (11726)
Issue : <https://www.acmicpc.net/problem/11726>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (3)
		n=4 => 경우의 수 (5)
		n=5 => 경우의 수 (8)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)
		즉, 피보나치 수열이다. (물론 두번째 값부터 조금 다르긴하다.)
	3. 일단 재귀함수로 진행했으나, 시간초과
	4. 다음은 공식을 적용시켜보았으나, 출력값이 너무 커서 오버플로우 발생
		-> 최대 크기의 자료형 또한 오버플로우가 난다.
	5. 그래서 반복문을 통해 이전 기록을 저장한 후에 진행해보니 성공
	
# 2. 코드 (11726)

```cpp
#include<cstdio>
#include<math.h>
const double pi = (1 + sqrt(5)) / 2;
int Fibo(int n) { return round(pow(pi, n) / sqrt(5)); }
//공식 쓰기 => 실패 : 반환값이 너무 커서 오버플로우가 일어난다.


int F(int n) {
	if (n == 1) return 1;
	else if (n == 2) return 2;
	else return F(n - 2) + F(n - 1);
}
//재귀함수 => 실패 : 시간초과

int main() {
	int n;
	int dp[10008];
	dp[1] = 1;
	dp[2] = 2;
	scanf("%d", &n);
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + dp[i-2] )  % 10007; //피보나치 수열 응용?
	}
	printf("%d\n", dp[n]);
	return 0;
}


```

# 3. 리뷰 (11726)

	- dp에 관해 약간의 감을 잡은 것 같긴하다. 재귀함수도 진행해보니 마무리 조건만 잘 적용하면 쉬워 보이긴한다. 그러나 메모리를 보니 생각보다 많다.
	%10007을 준 이유가 나누기를 그리해서 그런건데 생각해보니 n값은 1000이다.
	그리고 사실 이전값 두 개만 필요하니 사실 배열은 세 개만 필요하지 않을까?

		
# 1. 문제풀이 [2×n 타일링2] (11727)
Issue : <https://www.acmicpc.net/problem/11727>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1, 2x2로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (3)
		n=3 => 경우의 수 (5)
		n=4 => 경우의 수 (11)
		n=5 => 경우의 수 (21)

		여기서 규칙을 발견했다. F(n) = F(n-1)+2*F(n-2)
	3. 이전 코드에서 x2를 추가해 주었다.
	
# 2. 코드 (11727)

```cpp
#include<cstdio>

int main() {
	int n;
	int dp[1001];
	dp[1] = 1;
	dp[2] = 3;
	scanf("%d", &n);
	
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + 2*dp[i-2] )  % 10007;
	}
	printf("%d\n", dp[n]);
	return 0;
}

```

# 3. 리뷰 (11727)

	- 음주를 조금 한 상태에서 하느라 시간이 조금 걸렸다. 그러나 이전 코드와 비슷하게 진행되어서 생각보다는 수월하게 한 듯 싶다.



		
# 1. 문제풀이 [1, 2, 3 더하기] (9095)
Issue : <https://www.acmicpc.net/problem/9095>
## 1) 문제 조건
	- 케이스의 개수 T
	- 각각의 정수 n
	- n을 1, 2, 3의 합으로 나타내는 방법
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (4)
		n=4 => 경우의 수 (7)
		n=5 => 경우의 수 (13)
		n=6 => 경우의 수 (24)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)+f(n-3)
	
# 2. 코드 (9095)

```cpp
#include<cstdio>

int main() {
	int n;
	int t;
	int dp[11];
	dp[0] = 0;
	dp[1] = 1;
	dp[2] = 2;
	dp[3] = 4;
	for(int i=4; i<=10; i++) dp[i] = (dp[i-1] + dp[i-2]+dp[i-3]);
	scanf("%d", &t);
	for (int i = 0; i < t; i++) {
		scanf("%d", &n);
		printf("%d\n", dp[n]);
	}
	return 0;
}
```

# 3. 리뷰 (9095)

	- n의 범위가 10이하 였기에 반복문으로 미리 구하고 돌렸다.
	그리고 사실 생각하고 있던건, n이 4일 경우
	[ ]1[ ]1[ ]1[ ]1[ ]
	이런식으로 괄호를 채우는 경우의 수를 구하는 거였는데, 완전탐색으로는 구현할 수 있지 않을가 싶어서 생각해 봤었다.


		
<del>

		
# 1. 문제풀이 [쉬운 계단 수] (10844)
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (9)
		n=2 => 경우의 수 (18 - 1)
		n=3 => 경우의 수 (36 - 4)
		n=4 => 경우의 수 (72 - 10)

		여기서 규칙 - 부분이 수열의 합의 규칙을 갖는다.
		해서 minus dp를 따로 구해주었다.

	
# 2. 코드 (10844)

```cpp
#include<cstdio>
#include<cmath>
int main() {
	int n;
	int dp_tmp=1; //dp[2]일때, -되는 값
	int dp[101];
	int minus_dp[101];
	scanf("%d", &n);
	//int tmp = (9 * pow(2, n - 1) - pow(2, n - 2));
	dp[1] = 9;
	dp[2] = 18;
	minus_dp[1] = 0;
	minus_dp[2] = 1;
	for (int i = 3; i < n+1; i++) {
		dp[i] = dp[i-1]*2 % 1000000000;
		if (dp[i - 1] * 2 > 1000000000) printf("over dp[%d] = %d\n", i, dp[i]);
		minus_dp[i] = (2 * minus_dp[i-1] + 2)%1000000000;
		if ((2 * minus_dp[i-1] + 2) > 1000000000) printf("over minus_dp[%d] = %d\n", i, minus_dp[i]);
	}
	printf("%d\n",  dp[n]- minus_dp[n]);

	return 0;
}


```
</del>

# 3. 리뷰 (10844)
	- 실패
	- 점화식이 잘못되었다. 더욱 큰수들에게서 언제든 뒷자리가 9또는 0이 나올 가능성이 있어서 해당 코드는 맞지않는 코드였다.

# 1. 문제풀이 [쉬운 계단 수] (10844) -again
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 1의 자리 숫자의 개수들로 초점을 맞추면
		idx   0 1 2 3 4 5 6 7 8 9
		dp[0] 0 1 1 1 1 1 1 1 1 1
		=> 1,2,3,4,5,6,7,8,9

		idx   0 1 2 3 4 5 6 7 8 9
		dp[1] 1 1 2 2 2 2 2 2 2 1
		=> 10, 21, 12|32, 23|43..... 78|98, 89 

		idx   0 1 2 3 4 5 6 7 8 9
		dp[2] 1 3 3 4 4 4 4 4 3 2
		=> 210, 101|121|321, 212|232|432, 678|878|898, 789|989

		여기서 규칙을 알 수 있다.
		0과 9를 제외한 dp들은 dp[n][j] = dp[n-1][j-1] + dp[n-1][j+1]를 만족한다. (대각선으로 더하면 된다.)

	
# 2. 코드 (10844)

```cpp
#include<cstdio>

int main() {
	int n;
	int result=0; 
	int dp[2][10] = { 0,  };
	scanf("%d", &n);

	for (int i = 1; i < 10; i++) dp[1][i] = 1;

	for (int i = 2; i < n+1; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 0) dp[i % 2][j] = dp[(i - 1) % 2][j + 1] % 1000000000;
			else if (j == 9) dp[i % 2][j] = dp[(i - 1) % 2][j - 1] % 1000000000;
			else dp[i % 2][j] = (dp[(i - 1) % 2][j - 1] + dp[(i - 1) % 2][j + 1]) % 1000000000;
		}
	}

	for (int i = 0; i < 10; i++) result = (result + dp[n % 2][i]) % 1000000000;
	printf("%d\n", result);

	return 0;
}
```

# 3. 리뷰 (10844)

>	 이런식으로 생각할 생각을 아예 못했다. 매우 신박하다.
	이래서 1시간동안 고민하고 못 풀면 해답을 보란말이 매우 와 닿는다.
	
>	추가로 상기 코드는 2개의 배열만을 가지고 윗배열 아랫배열의 값을 참조하는
	 식의 형태인 `슬라이딩 윈도 기법`이라고 한다.

		