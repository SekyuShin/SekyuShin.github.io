---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



# DP 문제 풀이들

DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 

- [1463: 1로 만들기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1463)
- [11726: 2×n 타일링]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11726)
- [11727: 2×n 타일링2]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11727)
- [9095: 1, 2, 3 더하기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9095)
- [10844: 쉬운 계단 수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-10844)
- [11057: 오르막 수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11057)
- [2193: 이친수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2193)
- [9465: 스티커]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9465)
- [2156: 포도주 시식]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2156)
- [11053: 가장 긴 증가하는 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11053)
- [11055: 가장 큰 증가 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11055)
- [11722: 가장 긴 감소하는 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11722)
- [11054: 가장 긴 바이토닉 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11054)
- [1912: 연속합]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1912)
- [2579: 계단 오르기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2579)
- [1699: 제곱수의 합]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1699)
- [2133: 타일 채우기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2133) //재풀이
- [9461: 파도반 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9461)
- [2225: 합분해]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2225)
- [11052: 카드 구매하기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11052) //풀이진행중



# 1. 문제풀이 [암호코드] (2011) - fail
Issue : <https://www.acmicpc.net/problem/2011>
## 1) 문제 조건
	- A =1, B=2, ... Z = 26
	- BEAN => 25114
	- 25114 => "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 
	- 5000자리 이하
	- 이상하면 0 출력
	- 1000000로 나머지 출력

## 2)  문제 접근
	1. 
# 2. 코드  (2011) - fail

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int dp[2] = { 1, };
	char input;
	char past = '0';
	bool odd = 1;
	int mul = 1;


	while (input = getchar()) {
		if (input == '\n') 	break;
		
		else if (input == '0') {
			if (past == '0' || past > '2') {
				mul = 0;
				break;
			} else {
				dp[odd] = 1;
				dp[!odd] = 0;
			}
		} else if (input < '3')	dp[odd] = (dp[!odd] + dp[odd])%1000000;
		 else if ( past == '2' && input >'6') {
			dp[odd] = 1;
			dp[!odd] = 0;
		} else {
			mul *= ((dp[0] + dp[1]));
			mul %= 1000000;
			dp[odd] = 1;
			dp[!odd] = 0;
		}
		odd = !odd;
		past = input;
	}
	
	if (input < '3') mul *= dp[!odd];
	printf("%d\n", mul%1000000);
}

```
# 3. 코드  (2011)

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#define mod 1000000
using namespace std;

int main(){
	string s; cin>>s;
	int size = s.size();
	if(s[0]=='0'){
		cout<<0; return 0;
	}
	int dp[5001] = {1,1}; // dp의 0,1번째 값은 1
	for(int i=2; i<=size; i++){
		if(s[i-1]>'0') dp[i]=dp[i-1]%mod; //s의 현재값(i-1)이 0이 아닐 때

		int n =(s[i-2]-'0')*10 + s[i-1]-'0'; //s[i-2 ~ i-1]이 10~26일 때
		if(10<=n && 26>=n){
			dp[i] = (dp[i]+dp[i-2])%mod;
		}
	}
	cout<<dp[size];
}

```
# 3. 리뷰 (2011)

>	15퍼센트 빌런..
> 다시 풀이 시작 왜 문제가 안풀릴까나

> 결국 간만에 풀기도 했고 그래서 머리가 잘 안돌아가나 보다. 실패 후, 코드를 퍼왔다.

> 나중에 다시 도전!


