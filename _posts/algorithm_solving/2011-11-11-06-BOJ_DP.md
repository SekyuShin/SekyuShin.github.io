---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



# DP 문제 풀이들

DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 

- [1463: 1로 만들기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1463)
- [11726: 2×n 타일링]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11726)
- [11727: 2×n 타일링2]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11727)
- [9095: 1, 2, 3 더하기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9095)
- [10844: 쉬운 계단 수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-10844)
- [11057: 오르막 수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11057)
- [2193: 이친수]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2193)
- [9465: 스티커]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9465)
- [2156: 포도주 시식]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2156)
- [11053: 가장 긴 증가하는 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11053)
- [11055: 가장 큰 증가 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11055)
- [11722: 가장 긴 감소하는 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11722)
- [11054: 가장 긴 바이토닉 부분 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-11054)
- [1912: 연속합]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1912)
- [2579: 계단 오르기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2579)
- [1699: 제곱수의 합]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-1699)
- [2133: 타일 채우기]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2133) //시간을 두고 풀어 보아야 하기에 보류, 추가적으로 생각해야할듯..
- [9461: 파도반 수열]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-9461)
- [2225: 합분해]({{ site.url }}{{ site.baseurl }}/algorithm_solving/99-BOJ-2225)



# 1. 문제풀이 [타일 채우기] (2133)
Issue : <https://www.acmicpc.net/problem/2133>
## 1) 문제 조건
	- 3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수
	- N(1 ≤ N ≤ 30)

## 2)  문제 접근 (실패)
	1. 먼저 홀수자리는 절대 값이 나올수 없다. 
	2. 짝수 중, 2개 칸과 4개 칸만을 사용한다. => 실패이유
	3. 2개 칸의 경우의 수는 3이고, 4개 칸의 경우의 수는 2이다.
	4. 각각의 인덱스를 보면
		idx	0	1	2	3	4	5
		dp	1	3	11	39	139	495

		=> 여기서 각 모형은 이전값에서 2개 칸의 경우의 수가 추가된다. (*3)
		=> 또한 전전 값의 칸의수에서 *2의 규칙을 가진다.
		즉, dp[i] = 3 * dp[i - 1] + 2 * dp[i - 2];
	=> 접근은 좋았으나 추가적으로 생각해야하는 부분이 있다.	
## 3) 문제 접근 (성공)
	1. 먼저 홀수자리는 절대 값이 나올수 없다. 
	2. 총 세 부분으로 연산한다. (a, b, c)

![image](https://user-images.githubusercontent.com/42687768/149625617-10b153e0-668c-45a3-b28d-3fc2dee2b9e8.png)

	3. 상기 그림과 같이 각각의 세부분으로 나뉜다.
		a => 이전(i-1) dp값에서 추가로 인덱스 2번의 모형들을 곱해준다. (*3)
		b => 이전전 (i-2)이하의 dp값들에서 새로운 모형들을 곱해준다. (*2)
		c => 새로운 모형들
	4. 점화식을 생각해보기 위해서는
			2		4		6			8
	a	=>	3	 dp[2]*3  dp[4]*3 	 dp[8]*3
	b	=>	x		x	  dp[2]*2 dp[2]*2 + dp[4]*2	
	c	=>	x		2		2			2
	result	3		11		41			153
		즉, dp[i] = 3*dp[i-2] + 2*dp[i-4]+...+ 2*dp[2] + 2
# 2. 코드  (2133)

## 1) 실패코드

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int N;
	int dp[16] = { 1, };

	scanf("%d", &N);
	if (N % 2 == 1) {
		printf("0\n");
		return 0;
	} else {
		N /= 2;
		dp[1] = 3;
	
		for (int i = 2; i <= N; i++) {
			dp[i] = 3 * dp[i - 1] + 2 * dp[i - 2];
		}
		printf("%d\n", dp[N]);
	}
}

```
## 1) 성공코드

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int N;
	int dp[16] = { 1, };

	scanf("%d", &N);
	if (N % 2 == 1) {
		printf("0\n");
		return 0;
	} else {
		N /= 2;
		dp[1] = 3;
		for (int i = 2; i <= N; i++) {
			dp[i] = 3 * dp[i - 1]+2;
			for (int j = 1; j < i-1; j++) dp[i] += 2 * dp[j];
		}
		printf("%d\n", dp[N]);
	}
}
```
# 3. 리뷰 (2133)

>	추가적으로 생각해야하는 경우의 수들이 존재해서 처음에 실패했었다.
	조금더 심사숙고하며 풀어보자!





# 1. 문제풀이 [암호코드] (2011) - fail
Issue : <https://www.acmicpc.net/problem/2011>
## 1) 문제 조건
	- 

## 2)  문제 접근
	1. 
# 2. 코드  (2011) - fail

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int dp[2] = { 1, };
	char input;
	char past = '0';
	bool odd = 1;
	int mul = 1;


	while (input = getchar()) {
		if (input == '\n') 	break;
		
		else if (input == '0') {
			if (past == '0' || past > '2') {
				mul = 0;
				break;
			} else {
				dp[odd] = 1;
				dp[!odd] = 0;
			}
		} else if (input < '3')	dp[odd] = (dp[!odd] + dp[odd])%1000000;
		 else if ( past == '2' && input >'6') {
			dp[odd] = 1;
			dp[!odd] = 0;
		} else {
			mul *= ((dp[0] + dp[1]));
			mul %= 1000000;
			dp[odd] = 1;
			dp[!odd] = 0;
		}
		odd = !odd;
		past = input;
	}
	
	if (input < '3') mul *= dp[!odd];
	printf("%d\n", mul%1000000);
}

```
# 3. 코드  (2011)

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#define mod 1000000
using namespace std;

int main(){
	string s; cin>>s;
	int size = s.size();
	if(s[0]=='0'){
		cout<<0; return 0;
	}
	int dp[5001] = {1,1}; // dp의 0,1번째 값은 1
	for(int i=2; i<=size; i++){
		if(s[i-1]>'0') dp[i]=dp[i-1]%mod; //s의 현재값(i-1)이 0이 아닐 때

		int n =(s[i-2]-'0')*10 + s[i-1]-'0'; //s[i-2 ~ i-1]이 10~26일 때
		if(10<=n && 26>=n){
			dp[i] = (dp[i]+dp[i-2])%mod;
		}
	}
	cout<<dp[size];
}

```
# 3. 리뷰 (2011)

>	15퍼센트 빌런..
> 다시 풀이 시작 왜 문제가 안풀릴까나

> 결국 간만에 풀기도 했고 그래서 머리가 잘 안돌아가나 보다. 실패 후, 코드를 퍼왔다.

> 나중에 다시 도전!



# 1. 문제풀이 [카드 구매하기] (11052)
Issue : <https://www.acmicpc.net/problem/11052>
## 1) 문제 조건
	- 지불 금액의 최대를 구하자.
	- 첫번째 줄에 카드의 개수 N(1 ≤ N ≤ 1,000)
	- 두번째 줄에 카드 팩의 가치. (1 ≤ Pi ≤ 10,000)
	- 원하는 카드 수를 구할때 가장 값어치가 나가게 구하자.
## 2)  문제 접근
	1. DP를 구해서 해당하는 DP에 인덱스에 해당하는 최대값들을 넣어주었다.
	2. 다만, 해당 DP를 구하기 위해 이전 DP들의 합이 해당 DP의 인덱스가 되는 것들을 더해주었다.
	index 	1	2	3	4
	P		1	5	6	7
	dp		1	5	6	10
		=> dp[1] = P[1]
		=> dp[2] = max(P[2], 2*dp[1])
		=> dp[3] = max(P[3], dp[1]+dp[2])
		=> dp[4] = max(P[4], dp[1]+dp[3], 2*dp[2])

# 2. 코드  (11052)
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
	int N;
	int P[1001] = { 0, };
	int dp[1001] = { 0, };
	cin >> N;

	for (int i = 1; i < N+1; i++) {
		cin >> P[i];
	}
	dp[1] = P[1];
	for (int i = 2; i < N+1; i++) {
		dp[i] = P[i];
		for (int j = 1; j < i / 2+1; j++) {
			dp[i] = max(dp[i], dp[j]+dp[i - j]);
		}
		if (i % 2 == 0) {
			dp[i] = max(dp[i], 2 * dp[i / 2]);
		}
	}
	printf("%d\n", dp[N]);
	
}
```

# 3. 리뷰 (11052)

> 별 생각 없이 풀었는데 그냥 되었네. 뭘까 그냥 단순히 생각해서 이럴거 같아서 해본건데
> 털컥 성공해 버렸네. 다음 작업부터는 틀린문제를 다시 풀어보고, 쭉 이어진 현재문제들을 각각의 문제로 분해해서 올려야겠다.
