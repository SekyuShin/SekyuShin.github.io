---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



DP 문제 풀이들

# 1. 문제풀이 [1로 만들기] (1463)
Issue : <https://www.acmicpc.net/problem/1463>
## 1) 문제 조건
	- 정수 X에 관한 경우의 수
		- X가 3으로 나누어 떨어지면, 3으로 나눈다.
		- X가 2로 나누어 떨어지면, 2로 나눈다.
		- 1을 뺀다.
	- N은 1보다 크거나 같고, 10^6보다 작거나 같은 정수
## 2) 문제 접근
	1. 우선 10^6은 최대 값이 100만이다.
	2. 그냥 그리드 알고리즘으로 가능할 거 같은데..
		- 안된다. 물론 모든 경우의 수를 계산했을 경우에는 가능하겠지만.
			 ex) 10인 경우, 10->5->4->2->1 로 총 4번 그러나 최소값이기 때문에
				10->9->3->1 로 총 3번의 경우의 수가 나올 수 있다.
	3. 단순히 생각해보자.
		- f(1)은 0
		- f(2)는 1 (2->1)
		- f(3)은 1 (3->1)
		- f(4)는 2 (4->2->1(즉, 4->f(2)) or 4->3->1 (즉, 4->f(3)))
		- f(5)는 3 (5->f(4))
		- f(6)은 2 (6->f(3) or 6->f(2) or 6->f(5)(단, 이 경우는 최소값이 4이다.))


# 2. 코드 (1463)
```c
#include<cstdio>
int main() {
	int n;
	int count = 0;
	int *F = new int[1000001];
	
	scanf("%d", &n);
	F[1] = 0;

	for (int i = 2; i < n+1; i++) {
		count = F[i - 1];
		if (i % 3 == 0 && F[i/3] < count) count = F[i / 3];
		if (i % 2 == 0 && F[i / 2] < count) count = F[i / 2];
		F[i] = count + 1;
	}

	printf("%d\n", F[n]);
	return 0;
}


```

# 3. 리뷰 (1463)

	- DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 사실 적으면서 이게 맞나 싶기도 하니..
	우선 계속 해보자.

	PS. 다른 사람들의 문제를 보니, 재귀함수를 많이 쓴다. 흠.. 재귀함수로는 내일 도전!

# 4. 코드 (1463)
```c
#include<cstdio>
#include<algorithm>
int f(int n) {
	int a,b;
	if(n<2) 
		return 0;
	a=f(n/2)+n%2+1;
	b=f(n/3)+n%3+1;
	return std::min(a,b);
}
main(){
	int n;
	scanf("%d",&n);
	printf("%d",f(n));
}
```

# 4. 리뷰 (1463)
	- 일반적으로 dp문제를 풀 경우, 반복문을 사용하거나 재귀함수를 사용한다고 한다.
	위 풀이는 재귀함수를 사용한 예제다.
	조금 풀이를 해보자면, 나눈셈에 대한 몫만큼만 재귀함수를 사용하며 이후 카운트는 나눗셈에 대한 나머지와 1을 해준다. 뭔가 이해는 가지만 어떻게 이런 풀이가 가능한지 조금 더 생각해봐야겠다.


	
# 1. 문제풀이 [2×n 타일링] (11726)
Issue : <https://www.acmicpc.net/problem/11726>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (3)
		n=4 => 경우의 수 (5)
		n=5 => 경우의 수 (8)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)
		즉, 피보나치 수열이다. (물론 두번째 값부터 조금 다르긴하다.)
	3. 일단 재귀함수로 진행했으나, 시간초과
	4. 다음은 공식을 적용시켜보았으나, 출력값이 너무 커서 오버플로우 발생
		-> 최대 크기의 자료형 또한 오버플로우가 난다.
	5. 그래서 반복문을 통해 이전 기록을 저장한 후에 진행해보니 성공
	
# 2. 코드 (11726)

```cpp
#include<cstdio>
#include<math.h>
const double pi = (1 + sqrt(5)) / 2;
int Fibo(int n) { return round(pow(pi, n) / sqrt(5)); }
//공식 쓰기 => 실패 : 반환값이 너무 커서 오버플로우가 일어난다.


int F(int n) {
	if (n == 1) return 1;
	else if (n == 2) return 2;
	else return F(n - 2) + F(n - 1);
}
//재귀함수 => 실패 : 시간초과

int main() {
	int n;
	int dp[10008];
	dp[1] = 1;
	dp[2] = 2;
	scanf("%d", &n);
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + dp[i-2] )  % 10007; //피보나치 수열 응용?
	}
	printf("%d\n", dp[n]);
	return 0;
}


```

# 3. 리뷰 (11726)

	- dp에 관해 약간의 감을 잡은 것 같긴하다. 재귀함수도 진행해보니 마무리 조건만 잘 적용하면 쉬워 보이긴한다. 그러나 메모리를 보니 생각보다 많다.
	%10007을 준 이유가 나누기를 그리해서 그런건데 생각해보니 n값은 1000이다.
	그리고 사실 이전값 두 개만 필요하니 사실 배열은 세 개만 필요하지 않을까?

		
# 1. 문제풀이 [2×n 타일링2] (11727)
Issue : <https://www.acmicpc.net/problem/11727>
## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1, 2x2로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (3)
		n=3 => 경우의 수 (5)
		n=4 => 경우의 수 (11)
		n=5 => 경우의 수 (21)

		여기서 규칙을 발견했다. F(n) = F(n-1)+2*F(n-2)
	3. 이전 코드에서 x2를 추가해 주었다.
	
# 2. 코드 (11727)

```cpp
#include<cstdio>

int main() {
	int n;
	int dp[1001];
	dp[1] = 1;
	dp[2] = 3;
	scanf("%d", &n);
	
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + 2*dp[i-2] )  % 10007;
	}
	printf("%d\n", dp[n]);
	return 0;
}

```

# 3. 리뷰 (11727)

	- 음주를 조금 한 상태에서 하느라 시간이 조금 걸렸다. 그러나 이전 코드와 비슷하게 진행되어서 생각보다는 수월하게 한 듯 싶다.



		
# 1. 문제풀이 [1, 2, 3 더하기] (9095)
Issue : <https://www.acmicpc.net/problem/9095>
## 1) 문제 조건
	- 케이스의 개수 T
	- 각각의 정수 n
	- n을 1, 2, 3의 합으로 나타내는 방법
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (4)
		n=4 => 경우의 수 (7)
		n=5 => 경우의 수 (13)
		n=6 => 경우의 수 (24)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)+f(n-3)
	
# 2. 코드 (9095)

```cpp
#include<cstdio>

int main() {
	int n;
	int t;
	int dp[11];
	dp[0] = 0;
	dp[1] = 1;
	dp[2] = 2;
	dp[3] = 4;
	for(int i=4; i<=10; i++) dp[i] = (dp[i-1] + dp[i-2]+dp[i-3]);
	scanf("%d", &t);
	for (int i = 0; i < t; i++) {
		scanf("%d", &n);
		printf("%d\n", dp[n]);
	}
	return 0;
}
```

# 3. 리뷰 (9095)

	- n의 범위가 10이하 였기에 반복문으로 미리 구하고 돌렸다.
	그리고 사실 생각하고 있던건, n이 4일 경우
	[ ]1[ ]1[ ]1[ ]1[ ]
	이런식으로 괄호를 채우는 경우의 수를 구하는 거였는데, 완전탐색으로는 구현할 수 있지 않을가 싶어서 생각해 봤었다.


		
<del>

		
# 1. 문제풀이 [쉬운 계단 수] (10844)
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (9)
		n=2 => 경우의 수 (18 - 1)
		n=3 => 경우의 수 (36 - 4)
		n=4 => 경우의 수 (72 - 10)

		여기서 규칙 - 부분이 수열의 합의 규칙을 갖는다.
		해서 minus dp를 따로 구해주었다.

	
# 2. 코드 (10844)

```cpp
#include<cstdio>
#include<cmath>
int main() {
	int n;
	int dp_tmp=1; //dp[2]일때, -되는 값
	int dp[101];
	int minus_dp[101];
	scanf("%d", &n);
	//int tmp = (9 * pow(2, n - 1) - pow(2, n - 2));
	dp[1] = 9;
	dp[2] = 18;
	minus_dp[1] = 0;
	minus_dp[2] = 1;
	for (int i = 3; i < n+1; i++) {
		dp[i] = dp[i-1]*2 % 1000000000;
		if (dp[i - 1] * 2 > 1000000000) printf("over dp[%d] = %d\n", i, dp[i]);
		minus_dp[i] = (2 * minus_dp[i-1] + 2)%1000000000;
		if ((2 * minus_dp[i-1] + 2) > 1000000000) printf("over minus_dp[%d] = %d\n", i, minus_dp[i]);
	}
	printf("%d\n",  dp[n]- minus_dp[n]);

	return 0;
}


```
</del>

# 3. 리뷰 (10844)
	- 실패
	- 점화식이 잘못되었다. 더욱 큰수들에게서 언제든 뒷자리가 9또는 0이 나올 가능성이 있어서 해당 코드는 맞지않는 코드였다.

# 1. 문제풀이 [쉬운 계단 수] (10844) -again
Issue : <https://www.acmicpc.net/problem/10844>
## 1) 문제 조건
	- 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수
	- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 1의 자리 숫자의 개수들로 초점을 맞추면
		idx   0 1 2 3 4 5 6 7 8 9
		dp[0] 0 1 1 1 1 1 1 1 1 1
		=> 1,2,3,4,5,6,7,8,9

		idx   0 1 2 3 4 5 6 7 8 9
		dp[1] 1 1 2 2 2 2 2 2 2 1
		=> 10, 21, 12|32, 23|43..... 78|98, 89 

		idx   0 1 2 3 4 5 6 7 8 9
		dp[2] 1 3 3 4 4 4 4 4 3 2
		=> 210, 101|121|321, 212|232|432, 678|878|898, 789|989

		여기서 규칙을 알 수 있다.
		0과 9를 제외한 dp들은 dp[n][j] = dp[n-1][j-1] + dp[n-1][j+1]를 만족한다. (대각선으로 더하면 된다.)

	
# 2. 코드 (10844)

```cpp
#include<cstdio>

int main() {
	int n;
	int result=0; 
	int dp[2][10] = { 0,  };
	scanf("%d", &n);

	for (int i = 1; i < 10; i++) dp[1][i] = 1;

	for (int i = 2; i < n+1; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 0) dp[i % 2][j] = dp[(i - 1) % 2][j + 1] % 1000000000;
			else if (j == 9) dp[i % 2][j] = dp[(i - 1) % 2][j - 1] % 1000000000;
			else dp[i % 2][j] = (dp[(i - 1) % 2][j - 1] + dp[(i - 1) % 2][j + 1]) % 1000000000;
		}
	}

	for (int i = 0; i < 10; i++) result = (result + dp[n % 2][i]) % 1000000000;
	printf("%d\n", result);

	return 0;
}
```

# 3. 리뷰 (10844)

>	 이런식으로 생각할 생각을 아예 못했다. 매우 신박하다.
	이래서 1시간동안 고민하고 못 풀면 해답을 보란말이 매우 와 닿는다.
	
>	추가로 상기 코드는 2개의 배열만을 가지고 윗배열 아랫배열의 값을 참조하는
	 식의 형태인 `슬라이딩 윈도 기법`이라고 한다.

		

# 1. 문제풀이 [오르막 수] (11057)
Issue : <https://www.acmicpc.net/problem/11057>
## 1) 문제 조건
	- N (1 ≤ N ≤ 1,000)
	- 0으로 시작가능
	- 오르막 개수 (ex. 11, 12, 19 etc..)
	- 출력 : 10,007로 나눈 나머지
## 2) 문제 접근(1) - 실패
	1. 완전탐색? - 실패 (1000까지 숫자인줄 알고 완전탐색으로 진행했다가 생각해보니 1000자리수..)
## 3) 문제 접근(2)
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 1의 자리 숫자의 개수들로 초점을 맞추면
		idx   0 1 2 3 4 5 6 7 8 9
		dp[0] 1 1 1 1 1 1 1 1 1 1
		=> 0,1,2,3,4,5,6,7,8,9

		idx   0 1 2 3 4 5 6 7 8 9
		dp[1] 1 2 3 4 5 6 7 8 9 10
		=> 00 
		=> 01 11
		=> 02 12 22
		=> 03 13 23 33
		...
		=> 09 19 29 39 49 59 69 79 89 99

		idx   0 1 2  3  4  5  6  7  8  9
		dp[2] 1 3 6 10 15 21 28 36 45 55
		=> 000
		=> 001 011 111
		=> 002 012 112 022 122 222
		...
		=> 009 019 119 029 129 229 039... 099 199 299.. 899 999 (55)

	3. 규칙을 찾아보면, idx를 보면 자기자신을 포함한 작은 수의 idx들을 전부 더한값이 현재 idx의 값이란 것을 알 수 있다.
		ex)	dp[2][3] = dp[1][0]+dp[1][1]+dp[1][2]+dp[1][3] = 1+2+3+4 = 10

# 2. 코드 (11057) 

## 1. 실패 코드 (완전탐색)
```cpp
#include<cstdio>
#include<cmath>
int main() {
	int n;
	int count = 0;
	scanf("%d", &n);
	n = pow(10, n) - 1;
	for (int i = 1; i <= n; i++) {
		
		int tmp = i;
		int j_count = 0;
		bool checkUp = true;
		do {
			tmp /= 10;
			j_count++;
		} while (tmp > 0);
		//printf("%d : ", i);
		tmp = i;
		if (i > 10) {
			for (int j = j_count; j > 1; j--) {
				int tmp2 = tmp / pow(10, j-1);
				tmp =tmp % (int)pow(10, j-1);
				if (tmp2 > tmp / pow(10, j - 2)) {
					checkUp = false;
					break;
				}
				//printf("%d, %d\n", tmp2, tmp);
			}
			if (checkUp) count++;
		}
		else count++;

	}
	printf("%d\n", count);
	return 0;
}


```

## 2. 성공 코드 (DP)

```cpp
#include<cstdio>
int main() {
	int n;
	int dp[2][10] = { 0, };
	int ret = 0;
	scanf("%d", &n);

	for (int i = 0; i < 10; i++) {
		dp[1][i] = 1;
	}
	for (int i = 2; i < n + 1; i++) {
		for (int j = 0; j < 10; j++) {
			dp[i % 2][j] = 0;
			for (int z = 0; z < j + 1; z++) {
				dp[i % 2][j] += (dp[(i - 1) % 2][z] % 10007);
			}
		}
	}
	for (int i = 0; i < 10; i++) {
		ret += dp[n % 2][i]%10007;
	}
	printf("%d\n", ret % 10007);
	return 0;
}

```

# 3. 리뷰 (11057)

>	 위에서 풀었던 10844번 문제와 유사해서 금방 해결했던것 같다. 사실 DP문제기에 바로 배열을 두고 10844번 문제와 같이 풀 생각을 우선 하였지만, 1000이란 숫자에 완전탐색도 가능하지 않을까 시작했었다. (문제 지문 잘못 이해)

> 코드를 리뷰해 보자면, dp 배열을 두개로 둔  `슬라이딩 윈도 기법`을 사용했다. 다만 지금 보니 배열 한 개로 충분히 해결할 수 있어 보인다.

```cpp
	int dp[10] ={1,};
	for(int i=0;i<n;i++) {
		for(int j=1;j<10;j++) {
			dp[j] +=dp[j-1];
		}
	}
```
> <del>이런식으로 가능할 것 같다.</del> 임시 테스트를 잠시 진행해보니 가능하다. 메모리 낭비 및 시간 복잡도상 시간 낭비..

			

# 1. 문제풀이 [이친수] (2193)
Issue : <https://www.acmicpc.net/problem/2193>
## 1) 문제 조건
	- 0으로 시작하지 않는다.
	- 1이 두 번 연속으로 나타나지 않는다.
	- N(1 ≤ N ≤ 90)
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 우선 풀어서 찾아보자면
		dp[1] = 1 => 1
		dp[2] = 1 => 10
		dp[3] = 2 => 101, 100
		dp[4] = 3 => 1010, 1001, 1000
		dp[5] = 5 => 10100, 10101, 10010, 10001, 100000

		두 가지를 찾을 수 있는데, 하나는 맨 뒷자리가 0이면 다음 dp 인자로 1,0이 뒤에 붙어서 나올수 있으며, 맨 뒷자리가 1이면 무조건 1만 나와야한다.
		즉, 인덱스 0, 1을두고 
			idx   0 1
			dp[1] 0 1
			dp[2] 1 0
			dp[3] 1 1
			dp[4] 2 1
			dp[5] 3 2

		이런 식으로 dp[n][0] = dp[n-1][0] + dp[n-1][1]
				   dp[n][1] = dp[n-1][0]
		로 표현 가능해 진다.

		또는
		1, 1, 2, 3, 5의 규칙성을 보았을 때,
		dp[n] = dp[n-1] + dp[n-2]로 표현되기도 한다.

		n의 크기가 작기에 두 번째 방법으로 도출되어질 것 같아 두 번째 방법을 사용했다.
		
# 2. 코드 (2193) 

```cpp
#include<cstdio>
#include<iostream>

using namespace std;
int main() {
	unsigned long long  dp[91] = { 1,1, 1 };
	int n = 0;
	
	scanf("%d", &n);

	for (int i = 3; i <= n; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}

	cout << dp[n] << endl;
	
	return 0;
}



```

# 3. 리뷰 (2193)

>	 n의 크기가 90 이하지만 수 는 상당히 커진다. 그래서 처음 오버플로우가 발생했으나,
	 확인한 결과 8byte로 표현 가능한 수여서 그대로 진행하였다.

> 추가로 cout으로 표현해 주었는데, `printf`로 표현하기 위해서 출력형식을 `%lld`로 해주면 출력 가능해진다.


# 1. 문제풀이 [스티커] (9465) - 실패
Issue : <https://www.acmicpc.net/problem/9465>
## 1) 문제 조건
	- 첫째 줄에 테스트 케이스의 개수 T
	- 정수 n 개 (1 ≤ n ≤ 100,000)
	- 선택한  왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없다.
	- 각 스티커에는 점수가 존재할 때, 조건을 만족하는 최대 점수

## 2) 문제 접근 (실패 접근)
	1. 우선 문제 풀이에 실패 했었다.
	2. 처음 생각은 점화식으로 표현하여 재귀함수를 만드는 것이였다.
	3. return 조건을 F(i,j-2)+(!i,j-1) or F(!i,j-2)
		시간 초과가 나오면 인정은 하겠는데, 그냥 틀렸다. 재귀함수로 문제풀이 연습좀 해야겠다.
## 3) 문제 접근 (성공 접근)
	1. 다른 문제 풀이를 참고하였다. 전체적인 맥락은 비슷하나 접근이 달랐다.
	2. dp문제로 접근하여 입력값에서 최대한을 구해주는데 이때 +2까지를 구하는게 아닌 -1까지만을 보는것이다.

		쉽게 말해서,

![image](https://user-images.githubusercontent.com/42687768/147946833-d3a031c4-0e65-4d7f-9d05-362cd1e073fc.png)

		위 그림과 같은 경우에 수가 나오게 되는데 이때 이전값에 최대한을 넣어주는 것이다.

		dp   0    1    2
		[0]  50   40   200  
		[1]  30   100  120

		예를들면 dp[0][2] = buf[0][2] + max(dp[1][1], dp[1][0])의 값이 저장된다.

		즉, 점화식으로 표현하면 dp[0][i] = buf[0][i] + max(dp[1][i-1], dp[1][i-2])
		가된다. dp[1][i] 역시 비슷하게 동작한다.

![image](https://user-images.githubusercontent.com/42687768/147947635-7ef7a19d-23aa-4b71-ae79-94bcbb21a076.png)
		   

# 2. 코드 (9465) 

```cpp
#include<cstdio>
int **sticker = new int*[2];
int T, n;

int main() {
	scanf("%d", &T);
	for (int i = 0; i < T; i++) {
		scanf("%d", &n);
		for (int j = 0; j < 2; j++) sticker[j] = new int[n];
		for (int j = 0; j < 2; j++) {
			for (int z = 0; z < n; z++) scanf("%d", &sticker[j][z]);
		}
		sticker[0][1] += sticker[1][0];
		sticker[1][1] += sticker[0][0];
		for (int j = 2; j < n; j++) {
			sticker[0][j] += (sticker[1][j - 1] > sticker[1][j - 2] ? sticker[1][j - 1] : sticker[1][j - 2]);
			sticker[1][j] += (sticker[0][j - 1] > sticker[0][j - 2] ? sticker[0][j - 1] : sticker[0][j - 2]);
		}
		//for (int j = 0; j < n; j++) {
		//	printf("%d ", sticker[0][j]);
		//}printf("\n");
		//for (int j = 0; j < n; j++) {
		//	printf("%d ", sticker[1][j]);
		//}printf("\n");
		printf("%d\n", sticker[0][n - 1] > sticker[1][n - 1] ? sticker[0][n - 1] : sticker[1][n - 1]);

		for (int j = 0; j < 2; j++) delete[] sticker[j];
	}
	delete[] sticker;
	
	return 0;
}
```

# 3. 리뷰 (9465)

>	 두 가지를 배웠다. 다음만을 생각하지 말고, `이전 결과를 가지고 현재를 마련해야한다`

>	2중 배열의 동적 할당은 `int **sticker = new int*[2];` 으로 선언과 동시에 첫번째 배열을 선언해주고 반복문을 통해 , `for (int j = 0; j < 2; j++) sticker[j] = new int[n];`으로 두번째 배열을 선언해준다. 물론 해제 또한 잊지 말자 `for (int j = 0; j < 2; j++) delete[] sticker[j];, delete[] sticker;`

>	재귀함수 생성에 있어 애를 많이 먹었다. 뭔가 익숙치 않다고 해야하나, 다음 문제부터 왠만하면 두 가지 경우 전부 풀어 보아야 겠다. (시간 초과가 나올지언정 충분히 풀려야 하는 문제였다.)



# 1. 문제풀이 [포도주 시식] (2156) - 예외 확인후 성공
Issue : <https://www.acmicpc.net/problem/2156>
## 1) 문제 조건
	- 1 ≤ n ≤ 10,000
	- n개의 포도주중, 3번 연속해서 마시지 않고 최대한을 구해라

## 2) 문제 접근
	1. dp문제로 접근
	2. 입력과 dp를 나누어서 배열 생성
	3. dp에는 조건에 맞는 최대값을 입력
		- 이전 값이 연속인지 모르기 때문에 input[i-1]과 dp[i-3]을 합친값과
			: 인덱스를 하나 띄워 주었다 위의 경우에는 연속한 경우를 구한것이기 때문에
		- dp[i-2]를 비교해주었다. 
		- 즉, dp[i] = max(input[i - 1] + dp[i - 3], dp[i - 2]) + input[i];
		input 6  10  13   9   8   1
		dp    6  16  23  28  33  33
		=>  dp[2] = max(13+10, 13+6) = 23
		=>  dp[3] = max(9+13+6, 9+16) = 28
	4. 추가로 최대 2개까지 값을 띄울수 있기 때문에 해당 경우의 수도 구해주어야한다.
		-  100 400 1  2  4  200
		해당 반례의 경우에는 100, 400, 4, 200 즉, 2개까지 값을 띄웠다 해서 이전 dp값과 비교하여서 띄는 경우를 비교해주면된다.
		- dp[i] = max(dp[i],dp[i-1])

# 2. 코드 (2156) 

```cpp
#include<cstdio>
#include<algorithm>
int *dp;
int *input;
int T;
using namespace std;
int main() {
	int ret = 0;
	scanf("%d", &T);
	dp = new int[T];
	input = new int[T];
	for (int i = 0; i < T; i++) scanf("%d", &input[i]);

	if (T < 3) {
		for (int i = 0; i < T; i++) ret += input[i];
		printf("%d\n", ret);
		return 0;
	}

	dp[0] = input[0];
	dp[1] = input[1] + dp[0];
	dp[2] = max(input[1],dp[0]) + input[2];
	dp[2] = max(dp[1], dp[2]);
	for (int i = 3; i < T; i++) {
		dp[i] = max(input[i - 1] + dp[i - 3], dp[i - 2]) + input[i];
		dp[i] = max(dp[i-1],dp[i]);
	}

	//for (int i = 0; i < T; i++) {
	//	printf("%d  ", dp[i]);
	//}printf("\n");

	printf("%d\n", max(dp[T-1], dp[T - 2]));

	delete[] dp;
	delete[] input;

	return 0;
}


```

# 3. 리뷰 (11053)

>	 반례를 못찾아서 결국 실패했다. 지금생각해보면 구하기 힘든문제는 아니였는데 아쉽다.



# 1. 문제풀이 [가장 긴 증가하는 부분 수열] (11053)
Issue : <https://www.acmicpc.net/problem/11053>
## 1) 문제 조건
	- 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램
	- N (1 ≤ N ≤ 1,000)
	- 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 2) 문제 접근 (실패)
	1. 증가하는 수열이기에 입력마다 max값을 갱신하며 갱신할때마다 카운트
		=> 가장 긴 부분 수열이기에 기각
		ex) 1 2 10 3 4 5 => 1,2,3,4,5 (5)


## 3) 문제 접근 (성공)
	1. 입력배열과 해당하는 dp 배열 생성
	2. 이중 반복문을 통해 이전 입력배열들과 비교
	3. 이전 입력배열보다 현재 입력배열이 크다면 같은 index를 가진 dp의 값에서 +1한 값을 저장 (이때, 최대값을 저장해준다.)
		index	 0  1  2  3  4  5
		input	10 20 10 30 20 50
		dp	     1  2  1  3  2  4
	4.  if (input[i] > input[j]) dp[i] = max(dp[j]+1, dp[i]);
	5. 추가로 상기 예시 중, input[2]의 경우에는 보다 작은수가 없으므로 0이나오게 되지만 그 자체로 1개의 수열을 가지기에 `if (dp[i] == 0) dp[i] = 1;` 코드생성
		

# 2. 코드 (11053) 

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	
	int N;
	int input[1000] = { 0, };
	int dp[1000] = { 1, };
	int _max = 0;
	scanf("%d", &N);

	for (int i = 0; i < N; i++) {
		scanf("%d", &input[i]);
		for (int j = i; j >= 0; j--) 
			if (input[i] > input[j]) dp[i] = max(dp[j]+1, dp[i]);
		if (dp[i] == 0) dp[i] = 1;
		if (_max < dp[i])_max = dp[i];
	}
	
	printf("%d\n", _max);
}
```

# 3. 리뷰 (11053)

>	 쉽게 풀리긴 했으나 경우의 수가 컸다면 힘들었을 문제였다.
>	혹시 몰라 찾아보니 역시나 다른 풀이도 존재한다.
	후에 비슷한 경우를 찾으면 풀어보자 => `lower bound로 풀이`



# 1. 문제풀이 [가장 큰 증가 부분 수열] (11055)
Issue : <https://www.acmicpc.net/problem/11055>
## 1) 문제 조건
	- 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열의 합을 구하는 프로그램
	- N (1 ≤ N ≤ 1,000)
	- 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 2)  문제 접근
	1. 입력배열과 해당하는 dp 배열 생성
	2. 이중 반복문을 통해 이전 입력배열들과 비교
	3. 이전 입력배열보다 현재 입력배열이 크다면 같은 index를 가진 dp의 값에서 +input한 값을 저장 (이때, 최대값을 저장해준다.)
		index	 0  1  2  3  4  5
		input	10 20 10 30 20 50
		dp	    10 30 10 60 30 110
	4.  if (input[i] > input[j]) dp[i] = max(dp[j]+input[i], dp[i]);
	5. 추가로 상기 예시 중, input[2]의 경우에는 보다 작은수가 없으므로 0이나오게 되지만 그 자체로 1개의 수열을 가지기에 `if (dp[i] == 0) dp[i] = input[i];` 코드생성
		

# 2. 코드 (11055) 

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	
	int N;
	int input[1000] = { 0, };
	int dp[1000] = { 0, };
	int _max = 0;
	scanf("%d", &N);

	for (int i = 0; i < N; i++) {
		scanf("%d", &input[i]);
		for (int j = i; j >= 0; j--) if (input[i] > input[j]) dp[i] = max(dp[j]+input[i], dp[i]);
		if (dp[i] == 0)dp[i] = input[i];
		if (_max < dp[i])_max = dp[i];
	}
	//for (int i = 0; i < N; i++) {
	//	printf("%d ", dp[i]);
	//}printf("\n");
	
	printf("%d\n", _max);
}
```

# 3. 리뷰 (11055)

>	 이전 문제와 비슷해서 금방 풀 수 있었다.
> 	 예전에 풀었던 문제이나, 지금 방법과 유사하다. 이상한 구조체를 추가한거 뺴곤..
> 	근데 왜 메모리는 이전께 더 들쓰는지는 확인해봐야겠다.



# 1. 문제풀이 [가장 긴 감소하는 부분 수열] (11722)
Issue : <https://www.acmicpc.net/problem/11722>
## 1) 문제 조건
	- 수열 A가 주어졌을 때, 가장 긴 감소하는 부분의 길이를 구하는 프로그램
	- N (1 ≤ N ≤ 1,000)
	- 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 2)  문제 접근
	1. 가장 긴 감소하는 부분의 길이
		if (input[i] > input[j]) dp[i] = max(dp[j]+input[i], dp[i]);

# 2. 코드  (11722)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	
	int N;
	int input[1000] = { 0, };
	int dp[1000] = { 0, };
	int _max = 0;
	scanf("%d", &N);

	for (int i = 0; i < N; i++) {
		scanf("%d", &input[i]);
		for (int j = i; j >= 0; j--) if (input[i] < input[j]) dp[i] = max(dp[j]+1, dp[i]);
		if (dp[i] == 0)dp[i] = 1;
		if (_max < dp[i])_max = dp[i];
	}
	/*for (int i = 0; i < N; i++) {
		printf("%d ", dp[i]);
	}printf("\n");*/
	
	printf("%d\n", _max);
}
```

# 3. 리뷰 (11722)

>	 비슷한 문제


# 1. 문제풀이 [가장 긴 바이토닉 부분 수열] (11054)
Issue : <https://www.acmicpc.net/problem/11054>
## 1) 문제 조건
	- 수열 A가 주어졌을 때, 가장 긴 바이토닉 수열 부분의 길이를 구하는 프로그램
	- N (1 ≤ N ≤ 1,000)
	- 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 2)  문제 접근
	1. 바이토닉 수열이란 가장 큰 수를 기준으로 왼쪽에서는 증가 수열 오른쪽으로는 감소수열이 되야한다.
	2. 즉, 어느 한 input 배열의 인덱스를 기준으로 왼쪽은 0에서부터 증가수열
	오른쪽은 N-1부터 증가수열이 존재한다.
	3. 결론적으로 오른쪽으로 향하는 증가수열과 왼쪽으로 향하는 증가수열을 구해야한다.
		=> 최대의 값을 dp에 저장함으로 해당하는 인덱스에 최대값들이 저장됨으로 0부터 	
		시작한 dp와 N-1부터 시작한 dp에 해당하는 인덱스를 더해주면 바이토닉 부분 	
		수열의 최대값이 나온다.
	4. 예를 들면
	dp_up : 0부터 시작하는 증가수열
	dp_down : N-1부터 시작하는 증가수열

	input	1 5 2 1 4 3 4 5 2 1
	dp_up	1 2 2 1 3 3 4 5 2 1 
	dp_down	1 5 2 1 4 3 3 3 2 1

	input[0] => 왼쪽 수열이 없으므로 : 1, 오른쪽수열중 가장 작으므로 :1
	input[1] => 왼쪽 수열 : 1 5 , 오른쪽 수열 : 5 4 3 2 1 
	input[2] => 왼쪽 수열 : 1 2 , 오른쪽 수열 : 2 1

	즉, dp_up과 dp_down을 더한 값중 자기자신을 뺀(-1)이 바이토닉 수열이 된다.
		
# 2. 코드  (11054)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {

	int N;
	int input[1000] = { 0, };
	int dp_up[1000] = { 0, };
	int dp_down[1000] = { 0, };

	int _max = 0;

	scanf("%d", &N);

	for (int i = 0; i < N; i++) scanf("%d", &input[i]);
	for (int i = 0; i < N; i++) {
		for (int j = i; j >=0; j--) if (input[j]<input[i]) dp_up[i] = max(dp_up[j] + 1, dp_up[i]);
		if (dp_up[i] == 0) dp_up[i] = 1;
	}
	for (int i = N; i >=0; i--) {
		for (int j = i; j <N; j++) if (input[j] < input[i]) dp_down[i] = max(dp_down[j] + 1, dp_down[i]);
		if (dp_down[i] == 0) dp_down[i] = 1;
	}
	//for (int i = 0; i < N; i++) {
	//	printf("%d ", dp_up[i]);
	//}printf("\n");
	//for (int i = 0; i < N; i++) {
	//	printf("%d ", dp_down[i]);
	//}printf("\n");
	for (int i = 0; i < N; i++) {
		_max = max(dp_down[i] + dp_up[i], _max);
	}

	printf("%d\n", _max-1);
}
```

# 3. 리뷰 (11054)

>	 비슷한 문제이나 응용이 필요했다. 사실 증가수열을 구하고 감소수열을 구하면 나올 것 같다는 막연한 가정속에서 시작하였으며, 실제로 예시를 들며 바이토닉 부분 수열의 dp부분을 예제로 만들었다.

> 결론은 증가수열 부분은 예상이 맞았으나, 감소수열 부분은 0부터 시작하였으니 당연히 오른쪽으로 갈수록 값이 커지게 된다. 즉, 현재 인덱스값에서 최대값이 나오는게 아니므로 N-1부터 시작하는 증가수열을 구하니 답이 나왔다.

> 즉, 0부터 시작하는 감소수열의 경우 현재 인덱스가 작을때?? 햇깔린다. 현재 인덱스가 가장 클때를 구한거기때문에 맞지 않다..??



# 1. 문제풀이 [연속합] (1912)
Issue : <https://www.acmicpc.net/problem/1912>
## 1) 문제 조건
	- 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합
	- n(1 ≤ n ≤ 100,000)
	- 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수

## 2)  문제 접근
	1. 현재 인덱스를 포함한 이전값들의 최대값을 구하자.
	2. 예시로
		input	10 -4 3  1  5  6 -35 12 21 -1
		dp		10  6 9 10 15 21 -14 12 33 32
		=> 즉, 현재 index의 값과 dp[i-1]의 값이 0보다 크다면 계속 더하는게 이득이다.
		=> input[6]의 경우에는 -35이며 이전 dp[5]를 더한다하더라도 -14이므로 dp[7]의 입장에서는 더하면 오히려 수가 줄어들기때문에 0으로 초기화화 해준뒤 같은 점화식을 이어준다.
		=> 즉, if (i>=1 && dp[i - 1] > -1) dp[i] = dp[i - 1] + input[i];
		
# 2. 코드  (1912)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int N;
	int input[100000] = { 0, };
	int dp[100000] = { 0, };
	int _max = -1000;
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		scanf("%d", &input[i]);
		if (i>=1 && dp[i - 1] > -1) dp[i] = dp[i - 1] + input[i];
		else dp[i] = input[i];
		_max = max(_max, dp[i]);
	}
	//for (int i = 0; i < N; i++) {
	//	printf("%d ", dp[i]);
	//}printf("\n");
	printf("%d\n", _max);
}
```

# 3. 리뷰 (1912)

>	 이전에 풀었던 문제가 존재한다. 제출된 메모리와 시간을 보면 이전에 풀었던 문제가 훨씬 효율적이긴 하다. 위의 문제에서 dp를 사용하여 최대값들을 더해주었는데 이전풀었던 문제의 경우에는 따로 최대값을 정하진 않고, input값들을 합치는 sum_value와 최대값을 저장해주는 max_sum_value 단 두개의 변수로 문제를 풀었었다.
잘풀었었네..

- [1912번: 연속합]({{ site.url }}{{ site.baseurl }}/algorithm_solving/BOJ-1912)  



# 1. 문제풀이 [계단 오르기] (2579)
Issue : <https://www.acmicpc.net/problem/2579>
## 1) 문제 조건
	1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
	2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
	3. 마지막 도착 계단은 반드시 밟아야 한다.

	- 계단의 개수는 300이하의 자연수
	- 계단에 쓰여 있는 점수는 10,000이하의 자연수

## 2)  문제 접근
	1. 현재 인덱스를 포함한 이전값들의 최대값을 구하자.
	2. 예시로
		input	10 20 15 25 10 20
		dp		10 30 35 55 65 75
		=> dp[3]의 경우에는 인접한 input[2]값을 더하고 조건에 만족하도록 1번 건너 뛴 최대값인 dp[0]과 바로 1번 건너뛴 최대값인 dp[1]과 비교해서 최대값을 넣어준다.
		=> 즉, max(dp[i - 3] + input[i - 1], dp[i - 2]) + input[i];
		
		
# 2. 코드  (2579)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
int main() {
	int N;
	int input[300] = { 0, };
	int dp[300] = { 0, };
	scanf("%d", &N);
	for (int i = 0; i < N; i++) scanf("%d", &input[i]);
	
	dp[0] = input[0];
	dp[1] = dp[0] + input[1];
	dp[2] = max(input[0],input[1]) + input[2];

	for (int i = 3; i < N; i++) {
		dp[i] = max(dp[i - 3] + input[i - 1], dp[i - 2]) + input[i];
	}
	//for (int i = 0; i < N; i++) {
	//	printf("%d ", dp[i]);
	//}printf("\n");
	printf("%d\n", dp[N-1]);
}
```

# 3. 리뷰 (2579)

>	 2156번 문제와 유사하다 차이점이라면 2개를 건너뛸수 없으며 마지막 계단을 밟는 조건이 추가되어 몇개의 코드가 빠지거나 바뀐 차이만이 존재한다.
