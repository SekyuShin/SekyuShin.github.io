---

title: "BOJ_DP"  
excerpt: "Dynamic Programming 문제"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
 - DP
last_modified_at: 2021-12-21

---



DP 문제 풀이들

# 1. 문제풀이 [1로 만들기] (1463)
Issue : <https://www.acmicpc.net/problem/1463>
## 1) 문제 조건
	- 정수 X에 관한 경우의 수
		- X가 3으로 나누어 떨어지면, 3으로 나눈다.
		- X가 2로 나누어 떨어지면, 2로 나눈다.
		- 1을 뺀다.
	- N은 1보다 크거나 같고, 10^6보다 작거나 같은 정수
## 2) 문제 접근
	1. 우선 10^6은 최대 값이 100만이다.
	2. 그냥 그리드 알고리즘으로 가능할 거 같은데..
		- 안된다. 물론 모든 경우의 수를 계산했을 경우에는 가능하겠지만.
			 ex) 10인 경우, 10->5->4->2->1 로 총 4번 그러나 최소값이기 때문에
				10->9->3->1 로 총 3번의 경우의 수가 나올 수 있다.
	3. 단순히 생각해보자.
		- f(1)은 0
		- f(2)는 1 (2->1)
		- f(3)은 1 (3->1)
		- f(4)는 2 (4->2->1(즉, 4->f(2)) or 4->3->1 (즉, 4->f(3)))
		- f(5)는 3 (5->f(4))
		- f(6)은 2 (6->f(3) or 6->f(2) or 6->f(5)(단, 이 경우는 최소값이 4이다.))


# 2. 코드 (1463)
```c
#include<cstdio>
int main() {
	int n;
	int count = 0;
	int *F = new int[1000001];
	
	scanf("%d", &n);
	F[1] = 0;

	for (int i = 2; i < n+1; i++) {
		count = F[i - 1];
		if (i % 3 == 0 && F[i/3] < count) count = F[i / 3];
		if (i % 2 == 0 && F[i / 2] < count) count = F[i / 2];
		F[i] = count + 1;
	}

	printf("%d\n", F[n]);
	return 0;
}


```

# 3. 리뷰 (1463)

	- DP 정의에서 큰 문제를 부분 문제로 나누어 풀되, 특정 값에 대한 정답이 정해져 있으며(FUNCTION) 반복되면 안되며(기록) 분할정복이랑은 조금 다르다고 했는데 알듯 말듯 하다. 사실 적으면서 이게 맞나 싶기도 하니..
	우선 계속 해보자.

	PS. 다른 사람들의 문제를 보니, 재귀함수를 많이 쓴다. 흠.. 재귀함수로는 내일 도전!

# 4. 코드 (1463)
```c
#include<cstdio>
#include<algorithm>
int f(int n) {
	int a,b;
	if(n<2) 
		return 0;
	a=f(n/2)+n%2+1;
	b=f(n/3)+n%3+1;
	return std::min(a,b);
}
main(){
	int n;
	scanf("%d",&n);
	printf("%d",f(n));
}
```

# 4. 리뷰 (1463)
	- 일반적으로 dp문제를 풀 경우, 반복문을 사용하거나 재귀함수를 사용한다고 한다.
	위 풀이는 재귀함수를 사용한 예제다.
	조금 풀이를 해보자면, 나눈셈에 대한 몫만큼만 재귀함수를 사용하며 이후 카운트는 나눗셈에 대한 나머지와 1을 해준다. 뭔가 이해는 가지만 어떻게 이런 풀이가 가능한지 조금 더 생각해봐야겠다.