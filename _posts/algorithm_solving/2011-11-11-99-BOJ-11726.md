---

title: "BOJ_11726"  
excerpt: "DP"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - DP
 - cpp  
 - algorithm
last_modified_at: 2022-03-11

---
# 1. 문제풀이 [2×n 타일링] (11726)
Issue : <https://www.acmicpc.net/problem/11726>

+) 추가 조건

	1. 배열 세개만으로 풀어보기
	2. 경우의 수 노가다로 규칙성을 발견하지말고, 원리를 이해하고 풀어보기

## 1) 문제 조건
	- n이 주어진다. (1 ≤ n ≤ 1,000)
	- 2xn크기의 직사각형을 1x2, 2x1로 채우는 방법의수
	- 출력 : 2xn 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지 출력
## 2) 문제 접근
	1. 일단 특정 값에 대한 결과가 일정하다.
	2. 처음 접근은 직접 계산해 보았다.
		n=1 => 경우의 수 (1)
		n=2 => 경우의 수 (2)
		n=3 => 경우의 수 (3)
		n=4 => 경우의 수 (5)
		n=5 => 경우의 수 (8)

		여기서 규칙을 발견했다. F(n) = F(n-1)+F(n-2)
		즉, 피보나치 수열이다. (물론 두번째 값부터 조금 다르긴하다.)
	3. 일단 재귀함수로 진행했으나, 시간초과
	4. 다음은 공식을 적용시켜보았으나, 출력값이 너무 커서 오버플로우 발생
		-> 최대 크기의 자료형 또한 오버플로우가 난다.
	5. 그래서 반복문을 통해 이전 기록을 저장한 후에 진행해보니 성공
	
# 2. 코드 (11726)

```cpp
#include<cstdio>
#include<math.h>
const double pi = (1 + sqrt(5)) / 2;
int Fibo(int n) { return round(pow(pi, n) / sqrt(5)); }
//공식 쓰기 => 실패 : 반환값이 너무 커서 오버플로우가 일어난다.


int F(int n) {
	if (n == 1) return 1;
	else if (n == 2) return 2;
	else return F(n - 2) + F(n - 1);
}
//재귀함수 => 실패 : 시간초과

int main() {
	int n;
	int dp[10008];
	dp[1] = 1;
	dp[2] = 2;
	scanf("%d", &n);
	for(int i=3; i<=n; i++){
		dp[i] = (dp[i-1] + dp[i-2] )  % 10007; //피보나치 수열 응용?
	}
	printf("%d\n", dp[n]);
	return 0;
}


```

# 3. 리뷰 (11726)

	- dp에 관해 약간의 감을 잡은 것 같긴하다. 재귀함수도 진행해보니 마무리 조건만 잘 적용하면 쉬워 보이긴한다. 그러나 메모리를 보니 생각보다 많다.
	%10007을 준 이유가 나누기를 그리해서 그런건데 생각해보니 n값은 1000이다.
	그리고 사실 이전값 두 개만 필요하니 사실 배열은 세 개만 필요하지 않을까?

	추가) 1~5까지 숫자만보고 짐작을 했지만, 틀릴수도 있을 거 같다. 어떻게 좀 더 확실하게 할 수 있을까?
	추가2) iostream 보다, cstdio가 메모리를 훨씬 적게 먹는다.



