---

title: "BOJ_2331"  
excerpt: "분해합, 완전 탐색"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
last_modified_at: 2019-12-16

---

Issue : <https://www.acmicpc.net/problem/2231>

## 1. 문제풀이  

- - -

### 1) 문제 조건

- N의 분해합 = N+(N을 이루는 각 자리수의 합)  
- 위에서 N을 생성자라 칭함  

> 즉, N(생성자), M(N의 분해합) 이라 칭한다.  

- 자연수 N이 주어 졌을 때, 가장 작은 생성자를 구해라. (입력이 분해합)  
- N(1 ≤ N ≤ 1,000,000)  
- 출력이 없을 경우(생성자가 없을경우) 출력 0

### 2) 문제 접근 순서

(1) 2개의 반복문을 사용함으로, 시간복잡도는 O(N^2)를 가진다.  
(2) 분석한 결과 9의 텀으로 중복된 생성자가 나온다.  

![result](https://user-images.githubusercontent.com/42687768/70902129-7f5c3800-203f-11ea-86f2-3866ce810fd4.JPG)  

(3) 코드를 만들고 맞는 결과를 내었지만, 결론적으로 말하면 처음부터 완전 탐색으로 구하는게 코드 짜기도 편하고 직관적인 것 같다.  

> 결론 : 내가 짠 코드는 복잡하다..

## 2. 코드

- - -

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

int main() {
	int input_div_sum,creat_sum = 0;
	scanf("%d", &input_div_sum);
	for (int i = input_div_sum-1; i > 0; --i) {
		int temp, sum = 0;
		temp = i;
		sum = i;
		while (1) {
			sum += temp % 10;
			temp = temp / 10;
			if (temp == 0) break;
		}
		if (sum == input_div_sum) {
			creat_sum = i;
			break;
		}
	}
	if (creat_sum == 0) {
		printf("%d", 0);
		return 0;
	}
	//중복 생성자 확인
	for (int i = 9; i < creat_sum;i+=9) {
		int temp, sum;
		temp = creat_sum - i;
		sum = creat_sum - i;
		while (1) {
			sum += temp % 10;
			temp = temp / 10;
			if (temp == 0) break;
		}
		if (sum == input_div_sum) {
			creat_sum = creat_sum - i;
		}
	}
	printf("%d", creat_sum);

	return 0;
}
```

## 3. 코드(인터넷)  

- - -

```cpp
#include<cstdio>
using namespace std;

int n;

int main() {
	scanf("%d",&n);
	for(int i=0;i<n;i++) {
		int gen = i,tmp = i;
		while(tmp) { //N자릿수 더하기
			gen+=tmp%10;
			tmp/=10;
		}
		if(gen == n) { //맞는지 확인
			printf("%d\n",i);
			break;
		}
		if(i==n-1) printf("0\n"); //끝까지 없으면 0 출력
	}
	return 0;
}
```
