---

title: "BOJ_3085 - 사탕 게임"  
excerpt: "완전 탐색"  
toc: true  
toc_sticky: true  
toc_label: ""  
categories:  
 - algorithm_solving  
tags:  
 - solving  
 - cpp  
 - algorithm
last_modified_at: 2021-12-07

---

Issue : <https://www.acmicpc.net/problem/3085>

# 1. 문제풀이  

## 1) 문제 조건

- N*N크기에 사탕을 채워 놓는다.  
- 인접한 두 칸을 고른후, 사탕을 교환하고 가장 긴 연속 부분(행 or 열)을 찾는다.  
- N의 크기는 (3<=N<=50)  

> N의 크기가 작다 => 완전 탐색으로 가능할 정도로 크기가 작다.  

## 2) 문제 접근 순서

1. 시간 복잡도가 최대 50*50(50*50+50*50) = 1250만이므로 1초안에 가능하다.  
2. 입력 후, 전체 사탕들의 종류를 검사한다.
3. 인접 배열을 스왑한 후, 스왑한 배열의 행과 열만을 검사해준다. (시간절약으로 이런 생각을 했지만, N의 크기가 작아 쓸모가 없다.)  

> 예를 들어 좌우 교환이면, ㅓㅏ 방향 전부 계산, 위아래 교환이면 ㅗ,ㅜ 방향 전부 계산  

결론적으로 코드는 아래와 같이 나왔다.  

# 2. 코드

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>


char candy[50][50];
int candy_len;
int max_candy=-1000;

using namespace std;

void check() {
	for (int i = 0; i < candy_len; i++) {
		int row_result = 1, col_result = 1;
		for (int j = 0; j < candy_len - 1; j++) {
			if (candy[i][j] == candy[i][j + 1]) row_result++;
			else {
				max_candy = std::max(max_candy, row_result++);
				row_result = 1;
			}
			if (candy[j][i] == candy[j + 1][i]) col_result++;
			else {
				max_candy = std::max(max_candy, col_result);
				col_result = 1;
			}
		}
		max_candy = std::max(max_candy, col_result);
		max_candy = std::max(max_candy, row_result);

	}
}

int main() {
	scanf("%d", &candy_len);
	for (int i = 0; i < candy_len; i++) {
		for (int j = 0; j < candy_len; j++) {
			cin >> candy[i][j];
		}
	}
	check();

	for (int i = 0; i < candy_len; i++) {
		for (int j = 0; j < candy_len; j++) {
			if (i != candy_len-1) {
				swap(candy[i][j], candy[i+1][j]);
				check();
				swap(candy[i][j], candy[i+1][j]);
			}
			if (j != candy_len-1) {
				swap(candy[i][j], candy[i][j+1]);
				check();
				swap(candy[i][j], candy[i][j+1]);
			}
		}

	}
	printf("%d\n", max_candy);

	return 0;
}
```
# 3. 리뷰
> 틀렸음이 나와서 수정중..
> 수정 2번째, 배열 공부 다시 해야할 듯..
> 수정 3번째, 배열에 대해 하나씩 뜯어봐서 고치긴 했으나 조건 자체에 숨겨져 있다.
> 그냥 처음부터 다시하는게 더 빠를듯 싶다.