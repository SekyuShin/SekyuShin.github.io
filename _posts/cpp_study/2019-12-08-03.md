---
title:  "3.c와 차이점"
excerpt: "reference"

toc: true
toc_sticky: true
toc_label: ""

categories:
  - cpp_study
tags:
  - cpp
  - study

last_modified_at: 2019-12-08  
---

## 레퍼런스

- - -

### cpp 레퍼런스(reference, 참조자)의 도입

```cpp
#include <iostream>

int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

위 소스 코드는 `change_val`라는 함수에 인자를 포인터로 설정해 `number`의 주솟값을 받고 `*p`를 통해 `number`를 참조하여 그 값을 3으로 바꾸는 코드입니다.  
그런데 여기서 `&`를 없앤 개념이 바로 레퍼런스라고 한다.

```cpp
#include <iostream>

int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

위위에 소스코드와 비교를 하면, 인자값으로 `int &p`를 받고 `change_cal`함수 내에서도 인자 `p`를 `*`를 사용하지않고 참조하고 있다.
> **레퍼런스의 뜻은 참조, 참고란 뜻으로 다른 이름이란 의미를 가지고 있다. 그래서 흔히 c++에서 레퍼런스를 참조자라고도 한다.**  

위 경우 함수의 매개변수 `p`가 `number`변수의 다른 이름이 되는 것이다.
이러한 레퍼런스를 정의하는 방법은  

```cpp
int& ref = number;
```

이런식으로 정의할 수 있으며, 가장 중요한 특성으로는 **반드시 정의 시 초기화 되어야한다는 것이다.**  
이러한 레퍼런스와 포인터의 차이로는 포인터 자체는 `메모리 값을 보관하는 변수` 자체로 `재활용`이 가능하지만, 참조자는 그렇지 않다.  
참조자는 어떠한 메모리 공간을 할당받지않고 그냥 컴파일 시에 원래 가리키던 변수의 주소값으로 다 치환시킨다. `(*(주소값) 으로)`  

```cpp
x = 1;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

y = 2;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

z = 3;
std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
```

즉, 레퍼런스는 한 번 초기화 되면 다른 변수의 별명이 될 수 없다. `재활용성이 없다`
말 그대로 `레퍼런스는 변수의 다른 이름으로서, 변수와 동일하게 사용가능하다.`

### 레퍼런스 배열과 배열의 레퍼런스
